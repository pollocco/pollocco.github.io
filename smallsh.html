<html><head id="joplin-container-root-head">
	<meta charset="UTF-8">

	<style>

		#joplin-container-content {
			/* Needs this in case the content contains elements with absolute positioning */
			/* Without this they would just stay at a fixed position when scrolling */
			position: relative;
			padding-left: 10px;
			padding-right: 10px;

			/* Note: the height is set via updateBodyHeight(). Setting it here to 100% */
			/* won't work with some pages due to the position: relative */
		}

		mark {
			background: #F3B717;
			color: black;
		}

		.mark-selected {
			background: #CF3F00;
			color: white;
		}

		ul ul, ul ol, ol ul, ol ol   {
			margin-bottom: 0px;			
		}
	</style>
</head>

<body id="joplin-container-body">
	<div id="joplin-container-pluginAssetsContainer">
	<style>
	/* For styling the rendered Markdown */
body{
    font-family: Georgia, 'Times New Roman', Times, serif;
    color: #222222;
    max-width:1000px;
    margin:auto;
}

h2{
    font-family: 'Recursive Mn Lnr St', 'Consolas', 'Source Code Pro', monospace;
    color:#137752;
    text-decoration: underline;
    text-decoration-color: #FFB700;
}

h3, h4, h5, h6{
    font-family: 'Recursive Mn Lnr St', 'Consolas', 'Source Code Pro', monospace;
    color:#660047;
    padding-left: 0.5rem;
}

h1{
    font-family: 'Recursive Mn Lnr St', 'Consolas', 'Source Code Pro', monospace;
    color:#D5008F;
}

b-gray, b-green, b-red, b-blue, b-orange, b-pink, b-purple {
    width: 90%;
    display: block;
    margin-left: 20px; 
    padding: 10px;
    border: 1px solid;
    border-left: 5px solid;
    border-radius: 2px; 
    word-wrap: break-word;
    box-shadow: 3px 3px 7px 0 rgba(0,0,0,0.3) ; 
}

ul{
    list-style-type: none;
    background-color: rgba(185, 206, 236, 0.274);
    padding:10px;
}

ul ul {
    list-style-type: none;
    padding: 0;
    border-left: 1px solid #ddd;
    margin-left: 0.25em;
    width: 90%;
}

ul ul li.md-checkbox input[type=checkbox] {
    margin-left: 0px !important;
}

.md-checkbox .checkbox-label-checked{
    color:seagreen;
    font-family: 'Recursive Mn Lnr St', 'Consolas', 'Source Code Pro', monospace;
    font-weight:bolder;
    font-size:90%;
    text-shadow: 1px 1px lightgoldenrodyellow;
    opacity: 0.8 !important;
}

.md-checkbox .checkbox-label-unchecked{
    color:maroon;
}

li{
    margin-bottom: 0;
}

ul li.md-checkbox input[type=checkbox] {
    margin-left: 0px !important;
}

ul ul{
    background-color: white;
}

ul ul li {
    padding: 8px 16px;
    border-bottom: 1px solid #ddd;
    background-color: rgb(255, 255, 255);
    
}

li label{
	margin-left:1em;

}

ul li {
    padding: 8px 16px;
    border-bottom: 1px solid #ddd;
    background-color: rgb(255, 255, 255);
    
}

ul ul li:last-of-type{
    border-bottom: 0px;
    margin-bottom: 0.5rem;
}

b-gray {
    border-color: #b1bcc2;
    background-color: #e9edf0; 
 }

b-green {
    border-color: #5fa04e;
    background-color: #c5e5b4; 
} 


b-red {
    border-color: #f65354;
    background-color: #fad3d4; 
}

b-blue {
    border-color: #229ade;
    background-color: #bbe5fb; 
}

b-orange {
    border-color: #cf7506;
    background-color: #faf3d3; 
}


b-purple {
    border-color: #af74e8;
    background-color: #ead9fb; 
}

b-pink {
    border-color: #ed5393;
    background-color: #fad3e5; 
}
	</style>
	</div>
	<div id="joplin-container-markScriptContainer"></div>
	<div id="joplin-container-content" ondragstart="return false;" ondrop="return false;" ><div id="rendered-md"><h1 id="checklist">Checklist</h1>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-546" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:2');
			const label = document.getElementById(&quot;cb-label-md-checkbox-546&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:2 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-546" for="md-checkbox-546" class="checkbox-label-unchecked">Your shell must support command lines with a maximum length of 2048 characters, and a maximum of 512 arguments.</label></div></li>
</ul>
<h2 id="special-inputs">Special Inputs</h2>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-547" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:6');
			const label = document.getElementById(&quot;cb-label-md-checkbox-547&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:6 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-547" for="md-checkbox-547" class="checkbox-label-unchecked">Special symbols <code class="inline-code">&lt;</code> and <code class="inline-code">&gt;</code></label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-548" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:7');
			const label = document.getElementById(&quot;cb-label-md-checkbox-548&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:7 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-548" for="md-checkbox-548" class="checkbox-label-unchecked">Any line that begins with the # character is a comment line and should be ignored. Mid-line comments, such as the C-style //, will not be supported.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-549" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:8');
			const label = document.getElementById(&quot;cb-label-md-checkbox-549&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:8 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-549" for="md-checkbox-549" class="checkbox-label-unchecked">A blank line (one without any commands) should also do nothing.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-550" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:9');
			const label = document.getElementById(&quot;cb-label-md-checkbox-550&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:9 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-550" for="md-checkbox-550" class="checkbox-label-unchecked">Your program must expand any instance of "$$" in a command into the process ID of the smallsh itself. Your shell does not otherwise perform variable expansion.</label></div></li>
</ul>
<h2 id="built-in-commands">Built-in Commands</h2>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-551" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:13');
			const label = document.getElementById(&quot;cb-label-md-checkbox-551&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:13 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-551" for="md-checkbox-551" class="checkbox-label-unchecked">The <code class="inline-code">exit</code> command exits your shell. It takes no arguments.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-552" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:14');
			const label = document.getElementById(&quot;cb-label-md-checkbox-552&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:14 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-552" for="md-checkbox-552" class="checkbox-label-unchecked">Your shell must kill any other processes or jobs that your shell has started before it terminates itself.</label></div></li>
</ul>
</li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-553" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:15');
			const label = document.getElementById(&quot;cb-label-md-checkbox-553&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:15 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-553" for="md-checkbox-553" class="checkbox-label-unchecked">The <code class="inline-code">cd</code> command changes the working directory of <code class="inline-code">smallsh</code>.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-554" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:16');
			const label = document.getElementById(&quot;cb-label-md-checkbox-554&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:16 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-554" for="md-checkbox-554" class="checkbox-label-unchecked">By itself - with no arguments - it changes to the directory specified in the HOME environment variable.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-555" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:17');
			const label = document.getElementById(&quot;cb-label-md-checkbox-555&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:17 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-555" for="md-checkbox-555" class="checkbox-label-unchecked">This command can also take one argument: the path of a directory to change to. Your cd command should support both absolute and relative paths.</label></div></li>
</ul>
</li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-556" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:18');
			const label = document.getElementById(&quot;cb-label-md-checkbox-556&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:18 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-556" for="md-checkbox-556" class="checkbox-label-unchecked">The <code class="inline-code">status</code> command prints out either the exit status or the terminating signal of the last foreground process ran by your shell.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-557" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:19');
			const label = document.getElementById(&quot;cb-label-md-checkbox-557&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:19 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-557" for="md-checkbox-557" class="checkbox-label-unchecked">If this command is run before any foreground command is run, then it should simply return the exit status 0.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-558" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:20');
			const label = document.getElementById(&quot;cb-label-md-checkbox-558&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:20 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-558" for="md-checkbox-558" class="checkbox-label-unchecked"><code class="inline-code">status</code> should ignore built-in commands.</label></div></li>
</ul>
</li>
</ul>
<h2 id="executing-commands">Executing Commands</h2>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-559" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:24');
			const label = document.getElementById(&quot;cb-label-md-checkbox-559&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:24 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-559" for="md-checkbox-559" class="checkbox-label-unchecked">Your shell will execute any commands other than the 3 built-in command by using <code class="inline-code">fork()</code>, <code class="inline-code">exec()</code> and <code class="inline-code">waitpid()</code>.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-560" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:25');
			const label = document.getElementById(&quot;cb-label-md-checkbox-560&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:25 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-560" for="md-checkbox-560" class="checkbox-label-unchecked">Whenever a non-built in command is received, the parent (i.e., smallsh) will fork off a child.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-561" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:26');
			const label = document.getElementById(&quot;cb-label-md-checkbox-561&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:26 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-561" for="md-checkbox-561" class="checkbox-label-unchecked">Your shell should use the PATH variable to look for non-built in commands, and it should allow shell scripts to be executed</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-562" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:27');
			const label = document.getElementById(&quot;cb-label-md-checkbox-562&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:27 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-562" for="md-checkbox-562" class="checkbox-label-unchecked">If a command fails because the shell could not find the command to run, then the shell will print an error message and set the exit status to 1</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-563" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:28');
			const label = document.getElementById(&quot;cb-label-md-checkbox-563&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:28 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-563" for="md-checkbox-563" class="checkbox-label-unchecked">A child process must terminate after running a command (whether the command is successful or it fails).</label></div></li>
</ul>
</li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-564" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:29');
			const label = document.getElementById(&quot;cb-label-md-checkbox-564&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:29 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-564" for="md-checkbox-564" class="checkbox-label-unchecked">You must do any input and/or output redirection using <code class="inline-code">dup2()</code>. The redirection must be done before using <code class="inline-code">exec()</code> to run the command.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-565" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:30');
			const label = document.getElementById(&quot;cb-label-md-checkbox-565&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:30 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-565" for="md-checkbox-565" class="checkbox-label-unchecked">An input file redirected via stdin should be opened for reading only; if your shell cannot open the file for reading, it should print an error message and set the exit status to 1 (but don't exit the shell).</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-566" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:31');
			const label = document.getElementById(&quot;cb-label-md-checkbox-566&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:31 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-566" for="md-checkbox-566" class="checkbox-label-unchecked">Similarly, an output file redirected via stdout should be opened for writing only; it should be truncated if it already exists or created if it does not exist. If your shell cannot open the output file it should print an error message and set the exit status to 1 (but don't exit the shell).</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-567" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:32');
			const label = document.getElementById(&quot;cb-label-md-checkbox-567&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:32 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-567" for="md-checkbox-567" class="checkbox-label-unchecked">Both stdin and stdout for a command can be redirected at the same time.</label></div></li>
</ul>
</li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-568" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:33');
			const label = document.getElementById(&quot;cb-label-md-checkbox-568&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:33 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-568" for="md-checkbox-568" class="checkbox-label-unchecked">Any command without an &amp; at the end must be run as a foreground command and the shell must wait for the completion of the command before prompting for the next command.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-569" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:34');
			const label = document.getElementById(&quot;cb-label-md-checkbox-569&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:34 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-569" for="md-checkbox-569" class="checkbox-label-unchecked">For such commands, the parent shell does NOT return command line access and control to the user until the child terminates.</label></div></li>
</ul>
</li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-570" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:35');
			const label = document.getElementById(&quot;cb-label-md-checkbox-570&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:35 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-570" for="md-checkbox-570" class="checkbox-label-unchecked">Any non built-in command with an &amp; at the end must be run as a background command and the shell must not wait for such a command to complete. For such commands, the parent must return command line access and control to the user immediately after forking off the child.</label></div>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-571" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:36');
			const label = document.getElementById(&quot;cb-label-md-checkbox-571&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:36 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-571" for="md-checkbox-571" class="checkbox-label-unchecked">The shell will print the process id of a background process when it begins.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-572" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:37');
			const label = document.getElementById(&quot;cb-label-md-checkbox-572&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:37 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-572" for="md-checkbox-572" class="checkbox-label-unchecked">When a background process terminates, a message showing the process id and exit status will be printed. This message must be printed just before the prompt for a new command is displayed.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-573" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:38');
			const label = document.getElementById(&quot;cb-label-md-checkbox-573&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:38 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-573" for="md-checkbox-573" class="checkbox-label-unchecked">If the user doesn't redirect the standard input for a background command, then standard input should be redirected to /dev/null</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-574" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:39');
			const label = document.getElementById(&quot;cb-label-md-checkbox-574&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:39 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-574" for="md-checkbox-574" class="checkbox-label-unchecked">If the user doesn't redirect the standard output for a background command, then standard output should be redirected to /dev/null</label></div></li>
</ul>
</li>
</ul>
<h2 id="sigint">SIGINT</h2>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-575" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:43');
			const label = document.getElementById(&quot;cb-label-md-checkbox-575&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:43 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-575" for="md-checkbox-575" class="checkbox-label-unchecked">Your shell, i.e., the parent process, must ignore <code class="inline-code">SIGINT</code></label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-576" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:44');
			const label = document.getElementById(&quot;cb-label-md-checkbox-576&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:44 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-576" for="md-checkbox-576" class="checkbox-label-unchecked">Any children running as background processes must ignore <code class="inline-code">SIGINT</code></label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-577" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:45');
			const label = document.getElementById(&quot;cb-label-md-checkbox-577&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:45 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-577" for="md-checkbox-577" class="checkbox-label-unchecked">A child running as a foreground process must terminate itself when it receives <code class="inline-code">SIGINT</code></label></div></li>
</ul>
<h2 id="sigtstp">SIGTSTP</h2>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-578" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:49');
			const label = document.getElementById(&quot;cb-label-md-checkbox-578&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:49 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-578" for="md-checkbox-578" class="checkbox-label-unchecked">A CTRL-Z command from the keyboard sends a SIGTSTP signal to your parent shell process and all children at the same time (this is a built-in part of Linux).</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-579" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:50');
			const label = document.getElementById(&quot;cb-label-md-checkbox-579&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:50 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-579" for="md-checkbox-579" class="checkbox-label-unchecked">A child, if any, running as a foreground process must ignore SIGTSTP.</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-580" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:51');
			const label = document.getElementById(&quot;cb-label-md-checkbox-580&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:51 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-580" for="md-checkbox-580" class="checkbox-label-unchecked">Any children running as background process must ignore SIGTSTP.</label></div></li>
</ul>
<h4 id="when-the-parent-process-running-the-shell-receives-sigtstp">When the parent process running the shell receives SIGTSTP:</h4>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-581" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:55');
			const label = document.getElementById(&quot;cb-label-md-checkbox-581&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:55 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-581" for="md-checkbox-581" class="checkbox-label-unchecked">The shell must display an informative message (see below) immediately if it's sitting at the prompt, or immediately after any currently running foreground process has terminated</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-582" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:56');
			const label = document.getElementById(&quot;cb-label-md-checkbox-582&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:56 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-582" for="md-checkbox-582" class="checkbox-label-unchecked">The shell then enters a state where subsequent commands can no longer be run in the background. In this state, the &amp; operator should simply be ignored, i.e., all such commands are run as if they were foreground processes.</label></div></li>
</ul>
<h4 id="if-the-user-sends-sigtstp-again-then-your-shell-will">If the user sends SIGTSTP again, then your shell will:</h4>
<ul>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-583" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:60');
			const label = document.getElementById(&quot;cb-label-md-checkbox-583&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:60 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-583" for="md-checkbox-583" class="checkbox-label-unchecked">Display another informative message (see below) immediately after any currently running foreground process terminates</label></div></li>
<li class="md-checkbox joplin-checkbox"><div class="checkbox-wrapper"><input type="checkbox" id="md-checkbox-584" onclick="
		try {
			if (this.checked) {
				this.setAttribute('checked', 'checked');
			} else {
				this.removeAttribute('checked');
			}

			ipcProxySendToHost('checkboxclick:unchecked:61');
			const label = document.getElementById(&quot;cb-label-md-checkbox-584&quot;);
			label.classList.remove(this.checked ? 'checkbox-label-unchecked' : 'checkbox-label-checked');
			label.classList.add(this.checked ? 'checkbox-label-checked' : 'checkbox-label-unchecked');
		} catch (error) {
			console.warn('Checkbox unchecked:61 error', error);
		}
		return true;
	"><label id="cb-label-md-checkbox-584" for="md-checkbox-584" class="checkbox-label-unchecked">The shell then returns back to the normal condition where the &amp; operator is once again honored for subsequent commands, allowing them to be executed in the background.</label></div></li>
</ul>
</div></div>
	<script src="./lib.js"></script>

	<script>
	const ipcProxySendToHost = (methodName, arg) => {
		window.postMessage({ target: 'main', name: methodName, args: [ arg ] }, '*');
	}

	let pluginAssetsAdded_ = {};

	try {
		const contentElement = document.getElementById('joplin-container-content');

		const ipc = {};

		window.addEventListener('message', webviewLib.logEnabledEventHandler(event => {
			// Here we only deal with messages that are sent from the main Electro process to the webview.
			if (!event.data || event.data.target !== 'webview') return;

			const callName = event.data.name;
			const callData = event.data.data;

			if (!ipc[callName]) {
				console.warn('Missing IPC function:', event.data);
			} else {
				ipc[callName](callData);
			}
		}));
		
		// Note: the scroll position source of truth is "percentScroll_". This is easier to manage than scrollTop because
		// the scrollTop value depends on the images being loaded or not. For example, if the scrollTop is saved while
		// images are being displayed then restored while images are being reloaded, the new scrollTop might be changed
		// so that it is not greater than contentHeight. On the other hand, with percentScroll it is possible to restore
		// it at any time knowing that it's not going to be changed because the content height has changed.
		// To restore percentScroll the "checkScrollIID" interval is used. It constantly resets the scroll position during
		// one second after the content has been updated.
		//
		// ignoreNextScroll is used to differentiate between scroll event from the users and those that are the result
		// of programmatically changing scrollTop. We only want to respond to events initiated by the user.

		let percentScroll_ = 0;
		let checkScrollIID_ = null;

		// This variable provides a	way to skip scroll events for a certain duration.
		// In general, it should be set whenever the scroll value is set explicitely (programmatically)
		// so as to differentiate scroll events generated by the user (when scrolling the view) and those
		// generated by the application.
		let lastScrollEventTime = 0;

		function setPercentScroll(percent) {
			percentScroll_ = percent;
			contentElement.scrollTop = percentScroll_ * maxScrollTop();
		}

		function percentScroll() {
			return percentScroll_;
		}

		function restorePercentScroll() {
			lastScrollEventTime = Date.now();
			setPercentScroll(percentScroll_);
		}

		// Note that this function keeps track of what's been added so as not to add the same CSS files multiple times
		// It also means that once an asset has been added it is never removed from the view, which in many case is
		// desirable, but still something to keep in mind.
		function addPluginAssets(assets) {
			if (!assets) return;

			const pluginAssetsContainer = document.getElementById('joplin-container-pluginAssetsContainer');

			for (let i = 0; i < assets.length; i++) {
				const asset = assets[i];

				const assetId = asset.name ? asset.name : asset.path;
				if (pluginAssetsAdded_[assetId]) continue;
				pluginAssetsAdded_[assetId] = true;

				if (asset.mime === 'application/javascript') {
					const script = document.createElement('script');
					script.src = asset.path;
					pluginAssetsContainer.appendChild(script);
				} else if (asset.mime === 'text/css') {
					const link = document.createElement('link');
					link.rel = 'stylesheet';
					link.href = asset.path;
					pluginAssetsContainer.appendChild(link);
				}
			}
		}

		ipc.scrollToHash = (event) => {
			if (window.scrollToHashIID_) clearInterval(window.scrollToHashIID_);
			window.scrollToHashIID_ = setInterval(() => {
				if (document.readyState !== 'complete') return;
				clearInterval(window.scrollToHashIID_);
				const hash = event.hash.toLowerCase();
				const e = document.getElementById(hash);
				if (!e) {
					console.warn('Cannot find hash', hash);
					return;
				}
				e.scrollIntoView();

				// Make sure the editor pane is also scrolled
				setTimeout(() => {
					const percent = currentPercentScroll();
					setPercentScroll(percent);
					ipcProxySendToHost('percentScroll', percent);
				}, 10);
			}, 100);
		}

		// https://stackoverflow.com/a/1977898/561309
		function isImageReady(img) {
			if (!img.complete) return false;
			if (!img.naturalWidth || !img.naturalHeight) return false;
			return true;
		}

		function allImagesLoaded() {
			for (const image of document.images) {
				if (!isImageReady(image)) return false;
			}
			return true;
		}

		let checkAllImageLoadedIID_ = null;

		ipc.setHtml = (event) => {
			const html = event.html;

			markJsHackMarkerInserted_ = false;

			updateBodyHeight();

			contentElement.innerHTML = html;

			let previousContentHeight = contentElement.scrollHeight;
			let startTime = Date.now();
			restorePercentScroll();

			if (!checkScrollIID_) {
				checkScrollIID_ = setInterval(() => {
					const h = contentElement.scrollHeight;
					if (h !== previousContentHeight) {
						previousContentHeight = h;
						restorePercentScroll();
					}
					if (Date.now() - startTime >= 1000) {
						clearInterval(checkScrollIID_);
						checkScrollIID_ = null;
					}
				}, 1);
			}

			addPluginAssets(event.options.pluginAssets);

			if (event.options.downloadResources === 'manual') {
				webviewLib.setupResourceManualDownload();
			}

			document.dispatchEvent(new Event('joplin-noteDidUpdate'));

			if (checkAllImageLoadedIID_) clearInterval(checkAllImageLoadedIID_);

			checkAllImageLoadedIID_ = setInterval(() => {
				if (!allImagesLoaded()) return;

				clearInterval(checkAllImageLoadedIID_);
				ipcProxySendToHost('noteRenderComplete');
			}, 100);
		}

		ipc.setPercentScroll = (event) => {
			const percent = event.percent;

			if (checkScrollIID_) {
				clearInterval(checkScrollIID_);
				checkScrollIID_ = null;
			}

			lastScrollEventTime = Date.now();
			setPercentScroll(percent);
		}

		// HACK for Mark.js bug - https://github.com/julmot/mark.js/issues/127
		let markJsHackMarkerInserted_ = false;
		function addMarkJsSpaceHack(document) {
			if (markJsHackMarkerInserted_) return;
			
			const prepareElementsForMarkJs = (elements, type) => {
				// const markJsHackMarker_ = '&#8203; &#8203;'
				const markJsHackMarker_ = ' ';
				for (let i = 0; i < elements.length; i++) {
					if (!type) {
						elements[i].innerHTML = elements[i].innerHTML + markJsHackMarker_;
					} else if (type === 'insertBefore') {
						elements[i].insertAdjacentHTML('beforeBegin', markJsHackMarker_);
					}
				}
			}

			prepareElementsForMarkJs(document.getElementsByTagName('p'));
			prepareElementsForMarkJs(document.getElementsByTagName('div'));
			prepareElementsForMarkJs(document.getElementsByTagName('br'), 'insertBefore');
			markJsHackMarkerInserted_ = true;
		}

		let mark_ = null;
		let markSelectedElement_ = null;
		function setMarkers(keywords, options = null) {
			if (!options) options = {};

			// TODO: Add support for scriptType on mobile and CLI

			if (!mark_) {
				mark_ = new Mark(document.getElementById('joplin-container-content'), {
					exclude: ['img'],
					acrossElements: true,
				});
			}

			addMarkJsSpaceHack(document);

			mark_.unmark()

			if (markSelectedElement_) markSelectedElement_.classList.remove('mark-selected');

			let selectedElement = null;
			let elementIndex = 0;

			const onEachElement = (element) => {
				if (!('selectedIndex' in options)) return;

				if (('selectedIndex' in options) && elementIndex === options.selectedIndex) {
					markSelectedElement_ = element;
					element.classList.add('mark-selected');
					selectedElement = element;
				}
				
				elementIndex++;
			}

			const markKeywordOptions = {
				each: onEachElement,
			};

			if ('separateWordSearch' in options) markKeywordOptions.separateWordSearch = options.separateWordSearch;

			for (let i = 0; i < keywords.length; i++) {
				let keyword = keywords[i];

				markJsUtils.markKeyword(mark_, keyword, {
					pregQuote: pregQuote,
					replaceRegexDiacritics: replaceRegexDiacritics,
				}, markKeywordOptions);
			}

			ipcProxySendToHost('setMarkerCount', elementIndex);

			// We only scroll the element into view if the search just happened. So when the user type the search
			// or select the next/previous result, we scroll into view. However for other actions that trigger a
			// re-render, we don't scroll as this is normally not wanted.
			// This is to go around this issue: https://github.com/laurent22/joplin/issues/1833
			if (selectedElement && Date.now() - options.searchTimestamp <= 1000) selectedElement.scrollIntoView();
		}

		let markLoader_ = { state: 'idle', whenDone: null };
		ipc.setMarkers = (event) => {
			const keywords = event.keywords;
			const options = event.options;

			if (!keywords.length && markLoader_.state === 'idle') return;

			if (markLoader_.state === 'idle') {
				markLoader_ = {
					state: 'loading',
					whenDone: {keywords:keywords, options:options},
				};

				const script = document.createElement('script');
				script.onload = function() {
					markLoader_.state = 'ready';
					setMarkers(markLoader_.whenDone.keywords, markLoader_.whenDone.options);
				};

				script.src = '../../node_modules/mark.js/dist/mark.min.js';
				document.getElementById('joplin-container-markScriptContainer').appendChild(script);
			} else if (markLoader_.state === 'ready') {
				setMarkers(keywords, options);
			} else if (markLoader_.state === 'loading') {
				markLoader_.whenDone = {keywords:keywords, options:options};
			}
		}

		function maxScrollTop() {
			return Math.max(0, contentElement.scrollHeight - contentElement.clientHeight);
		}

		// The body element needs to have a fixed height for the content to be scrollable
		function updateBodyHeight() {
			document.getElementById('joplin-container-body').style.height = window.innerHeight + 'px';
			document.getElementById('joplin-container-content').style.height = window.innerHeight + 'px';
		}

		function currentPercentScroll() {
			const m = maxScrollTop();
			return m ? contentElement.scrollTop / m : 0;
		}

		contentElement.addEventListener('scroll', webviewLib.logEnabledEventHandler(e => {
			// If the last scroll event was done by the user, lastScrollEventTime is set and
			// we can use that to skip the event handling. We skip it because in that case
			// the scroll position has already been updated. Also we add a 200ms interval
			// because otherwise it's most likely a glitch where we called ipc.setPercentScroll
			// but the scroll event listener has not been called.
			if (lastScrollEventTime && Date.now() - lastScrollEventTime < 200) {
				lastScrollEventTime = 0;
				return;
			}

			lastScrollEventTime = 0;

			const percent = currentPercentScroll();
			setPercentScroll(percent);
			
			ipcProxySendToHost('percentScroll', percent);
		}));

		document.addEventListener('contextmenu', webviewLib.logEnabledEventHandler(event => {
			let element = event.target;

			// To handle right clicks on resource icons
			if (element && !element.getAttribute('data-resource-id')) element = element.parentElement;

			if (element && element.getAttribute('data-resource-id')) {
				ipcProxySendToHost('contextMenu', {
					type: element.getAttribute('src') ? 'image' : 'resource',
					resourceId: element.getAttribute('data-resource-id'),
				});
			} else {
				const selectedText = window.getSelection().toString();

				if (selectedText) {
					ipcProxySendToHost('contextMenu', {
						type: 'text',
						textToCopy: selectedText,
					});
				} else if (event.target.getAttribute('href')) {
					ipcProxySendToHost('contextMenu', {
						type: 'link',
						textToCopy: event.target.getAttribute('href'),
					});
				}
			}
		}));

		webviewLib.initialize({
			postMessage: ipcProxySendToHost,
		});

		// Disable drag and drop otherwise it's possible to drop a URL
		// on it and it will open in the view as a website.
		document.addEventListener('drop', webviewLib.logEnabledEventHandler(e => {
			e.preventDefault();
			e.stopPropagation();
		}));
		document.addEventListener('dragover', webviewLib.logEnabledEventHandler(e => {
			e.preventDefault();
			e.stopPropagation();
		}));
		document.addEventListener('dragover', webviewLib.logEnabledEventHandler(e => {
			e.preventDefault();
		}));

		window.addEventListener('resize', webviewLib.logEnabledEventHandler(() => {
			updateBodyHeight();
		}));

		// Prevent middle-click as that would open the URL in an Electron window
		// https://github.com/laurent22/joplin/issues/3287
		window.addEventListener('auxclick', webviewLib.logEnabledEventHandler((event) => {
			event.preventDefault();
		}));

		updateBodyHeight();
	} catch (error) {
		ipcProxySendToHost('error:' + JSON.stringify(webviewLib.cloneError(error)));
		throw error;
	}
	</script>


</body></html>
